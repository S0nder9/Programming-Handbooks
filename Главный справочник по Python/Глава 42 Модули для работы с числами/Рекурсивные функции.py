# Глава 42: Модули для работы с числами - Рекурсивные функции

# Рекурсивные функции

# Рекурсивные функции - это функции, которые вызывают сами себя. 
# Они используются для решения задач, которые могут быть разбиты на несколько подзадач, схожих с исходной задачей. 
# Рекурсия - это мощный инструмент в программировании, но ее нужно использовать с осторожностью, чтобы избежать бесконечной рекурсии.

# Как работают рекурсивные функции?

# Когда функция вызывает саму себя, происходит так называемая рекурсия. 
# Однако для успешного завершения рекурсии всегда должен быть базовый случай - это условие, при котором рекурсия останавливается.
# Без базового случая функция будет вызывать саму себя бесконечно, что приведет к переполнению стека вызовов.

# Рекурсия полезна, когда задача может быть разделена на подобные подзадачи.
# Например, вычисление факториала числа, решение задач с деревьями и графами, а также многие другие задачи могут быть решены рекурсивно.

# Пример 1: Вычисление факториала числа
# Факториал числа n (обозначается как n!) — это произведение всех целых чисел от 1 до n.
# Например, 5! = 5 * 4 * 3 * 2 * 1 = 120

def factorial(n):
    # Базовый случай: факториал 0 или 1 равен 1
    if n == 0 or n == 1:
        return 1
    # Рекурсивный случай: n * факториал (n-1)
    return n * factorial(n - 1)

# Пример использования
number = 5
print(f"Факториал числа {number} равен {factorial(number)}")

# Пример 2: Рекурсивное вычисление чисел Фибоначчи
# Последовательность Фибоначчи - это последовательность, где каждое следующее число является суммой двух предыдущих.
# Например, первые 6 чисел Фибоначчи: 0, 1, 1, 2, 3, 5

def fibonacci(n):
    # Базовые случаи: возвращаем n, если n равно 0 или 1
    if n == 0 or n == 1:
        return n
    # Рекурсивный случай: сумма двух предыдущих чисел Фибоначчи
    return fibonacci(n - 1) + fibonacci(n - 2)

# Пример использования
fib_number = 6
print(f"{fib_number}-е число Фибоначчи: {fibonacci(fib_number)}")

# Пример 3: Рекурсия для подсчета суммы элементов списка
def sum_list(numbers):
    # Базовый случай: если список пустой, возвращаем 0
    if len(numbers) == 0:
        return 0
    # Рекурсивный случай: первый элемент списка + сумма остальных элементов
    return numbers[0] + sum_list(numbers[1:])

# Пример использования
numbers_list = [1, 2, 3, 4, 5]
print(f"Сумма элементов списка: {sum_list(numbers_list)}")

# Преимущества и недостатки рекурсии

# Преимущества:
# 1. Удобство для решения задач, которые могут быть разделены на подзадачи.
# 2. Часто приводит к кратким и чистым решениям сложных проблем.
# 3. Естественная форма для задач, связанных с деревьями и графами.

# Недостатки:
# 1. Возможность переполнения стека вызовов при слишком глубокой рекурсии.
# 2. В некоторых случаях рекурсивные решения могут быть менее эффективными по сравнению с итеративными решениями из-за большого количества вызовов функций.

# Итог
# Рекурсивные функции - это полезный инструмент для решения сложных задач, которые можно разделить на подобные подзадачи.
# При их использовании всегда нужно помнить о базовом случае, чтобы избежать бесконечной рекурсии.
# Примеры задач, где рекурсия полезна: факториалы, числа Фибоначчи, обход деревьев и графов.
