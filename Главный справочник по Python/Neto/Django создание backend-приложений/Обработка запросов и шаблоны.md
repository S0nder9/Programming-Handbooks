# Обработка запросов и шаблоны в Django

Этот документ описывает работу с конфигурацией Django, обработку HTTP-запросов, настройку маршрутов с использованием конвертеров, создание HTML-шаблонов и реализацию пагинации для постраничного отображения данных.

---

## Конфигурация Django

Файл `settings.py`, расположенный в главном пакете проекта, определяет настройки Django. В нём уже заданы стандартные переменные, такие как `INSTALLED_APPS`, `DATABASES`, `DEBUG` и другие.

### Пользовательские настройки
Вы можете добавлять свои переменные в `settings.py` и использовать их в приложении.

**Пример:**
```python
# settings.py
CONTACT_EMAIL = 'admin@example.com'
```

**Использование настроек:**
```python
from django.conf import settings
from django.http import HttpResponse

def hello_view(request):
    msg = f'Свяжитесь с админом: {settings.CONTACT_EMAIL}'
    return HttpResponse('Всем привет! Я Django! ' + msg)
```

**Пояснение:**
- Импортируйте `settings` из `django.conf` для доступа к конфигурации.
- Используйте `settings.VARIABLE_NAME` для получения значений.
- Для чувствительных данных (например, `CONTACT_EMAIL`) рекомендуется использовать переменные окружения:
  ```python
  import os
  CONTACT_EMAIL = os.getenv('CONTACT_EMAIL', 'admin@example.com')
  ```

**Дополнительно:** Подробная информация о настройках доступна в [документации Django](https://docs.djangoproject.com/en/stable/ref/settings/).

---

## Обработка параметров запросов

Django позволяет обрабатывать параметры, переданные в URL, через **query-параметры** или **динамические маршруты**.

### Query-параметры
Query-параметры передаются в URL после `?`, например: `http://127.0.0.1:8000/hi/?name=Sasha&age=22`.

**Пример:**
```python
# views.py
from django.http import HttpResponse

def hi(request):
    name = request.GET.get('name', 'Anonymous')  # Значение по умолчанию
    age = int(request.GET.get('age', 20))       # Преобразование в int
    return HttpResponse(f'Hi, {name}, age: {age}')
```

**Пояснение:**
- `request.GET` — словарь с query-параметрами.
- Метод `.get()` позволяет указать значение по умолчанию, если параметр отсутствует.
- В `urls.py` для этого маршрута ничего менять не нужно:
  ```python
  path('hi/', hi, name='hi'),
  ```

### Параметры в URL
Параметры можно включить непосредственно в путь URL, например: `http://127.0.0.1:8000/sum/1/2/`.

**Пример:**
```python
# views.py
from django.http import HttpResponse

def sumFn(request, op1, op2):
    res = op1 + op2
    return HttpResponse(f'Sum: {res}')
```

**Маршрут в `urls.py`:**
```python
from django.urls import path
from .views import sumFn

urlpatterns = [
    path('sum/<int:op1>/<int:op2>/', sumFn, name='sum'),
]
```

**Пояснение:**
- `<int:op1>` и `<int:op2>` — конвертеры, которые извлекают параметры из URL и преобразуют их в целые числа.
- Параметры передаются в функцию `sumFn` как аргументы.

---

## Конвертеры маршрутов в Django

Django позволяет создавать пользовательские конвертеры маршрутов для обработки сложных данных в URL, таких как даты или UUID.

### Требования к конвертеру
1. **Атрибут `regex`:** Регулярное выражение для проверки формата параметра.
2. **Метод `to_python(self, value: str)`:** Преобразует строку из URL в Python-объект.
3. **Метод `to_url(self, value) -> str`:** Преобразует Python-объект обратно в строку для генерации URL.

**Пример: Конвертер для дат**
1. Создайте файл `converters.py` в приложении:
   ```python
   import datetime

   class DateConverter:
       regex = r'[0-9]{4}-[0-9]{2}-[0-9]{2}'  # Формат YYYY-MM-DD
       format = '%Y-%m-%d'

       def to_python(self, value: str) -> datetime:
           return datetime.datetime.strptime(value, self.format)

       def to_url(self, value: datetime.datetime) -> str:
           return value.strftime(self.format)
   ```

2. Зарегистрируйте конвертер в `urls.py`:
   ```python
   from django.urls import path, register_converter
   from . import converters, views

   register_converter(converters.DateConverter, 'dateCustom')

   urlpatterns = [
       path('date/<dateCustom:date>/', views.r_view, name='r_view'),
   ]
   ```

3. Создайте представление в `views.py`:
   ```python
   from django.http import HttpResponse

   def r_view(request, date):
       return HttpResponse(f'Received date: {date}')
   ```

**Пояснение:**
- `regex` проверяет, что строка соответствует формату даты (например, `2025-07-07`).
- `to_python` преобразует строку в объект `datetime`.
- `to_url` используется для генерации URL с помощью `reverse`.

---

## Шаблоны HTML

Шаблоны в Django — это HTML-файлы с динамическим содержимым, которое генерируется на основе данных из представлений.

### Настройка шаблонов
1. В `settings.py` убедитесь, что директория шаблонов указана в `TEMPLATES`:
   ```python
   TEMPLATES = [
       {
           'BACKEND': 'django.template.backends.django.DjangoTemplates',
           'DIRS': [],  # Можно добавить путь к общим шаблонам
           'APP_DIRS': True,  # Автоматический поиск шаблонов в папке templates каждого приложения
           ...
       },
   ]
   ```

2. Создайте папку `templates` в приложении и добавьте файл, например, `demo.html`:
   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Document</title>
   </head>
   <body>
       <h1>{{ name }}, {{ age }}</h1>
       <!-- Отображение переменных из context -->
       <ul>
           {% for x in data %}
               {% if x > 5 %}
                   <li>{{ x }}</li>
               {% endif %}
           {% endfor %}
       </ul>
       <!-- Вызов методов переменной -->
       <p>{{ val.upper }}</p>
   </body>
   </html>
   ```

3. В `views.py` передайте данные в шаблон с помощью функции `render`:
   ```python
   from django.shortcuts import render

   def hi(request):
       name = request.GET.get('name', 'Anonymous')
       age = int(request.GET.get('age', 20))
       context = {
           'name': name,
           'age': age,
           'data': [1, 2, 10],
           'val': 'hello'
       }
       return render(request, 'demo.html', context)
   ```

**Пояснение:**
- `{{ variable }}` — отображает значение переменной из контекста.
- `{% for %}`, `{% if %}` — теги для циклов и условий.
- `{{ val.upper }}` — вызывает метод Python-объекта (например, преобразование строки в верхний регистр).

---

## Пагинация

Пагинация позволяет отображать контент постранично, что полезно для больших наборов данных.

### Реализация пагинации
1. В `views.py` используйте класс `Paginator`:
   ```python
   from django.core.paginator import Paginator
   from django.shortcuts import render

   CONTENT = [str(i) for i in range(1, 10_001)]

   def pagi(request):
       page_number = request.GET.get('page', 1)
       paginator = Paginator(CONTENT, 10)  # 10 элементов на страницу
       page = paginator.get_page(page_number)
       context = {
           'paginator': paginator,
           'page': page
       }
       return render(request, 'pagi.html', context)
   ```

2. Создайте шаблон `pagi.html` в папке `templates`:
   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>Pagination</title>
   </head>
   <body>
       {% for e in page %}
           <p>{{ e }}</p>
       {% endfor %}
       {% if page.has_previous %}
           <a href="?page={{ page.previous_page_number }}">Назад</a>
       {% endif %}
       {% if page.has_next %}
           <a href="?page={{ page.next_page_number }}">Вперед</a>
       {% endif %}
   </body>
   </html>
   ```

**Пояснение:**
- `Paginator(CONTENT, 10)` разбивает список `CONTENT` на страницы по 10 элементов.
- `paginator.get_page(page_number)` возвращает объект страницы, учитывая запрошенный номер.
- В шаблоне `page` содержит элементы текущей страницы, а `has_previous` и `has_next` позволяют отображать ссылки навигации.

---

## Рекомендации по работе

1. **Безопасность:**
   - Используйте `request.GET.get()` для безопасного доступа к query-параметрам.
   - Для пользовательских данных в шаблонах применяйте фильтр `|escape` для защиты от XSS-атак:
     ```html
     <p>{{ user_input|escape }}</p>
     ```

2. **Читаемость кода:**
   - Используйте понятные имена для маршрутов, переменных и шаблонов.
   - Форматируйте HTML-шаблоны с отступами для удобства чтения.

3. **Оптимизация пагинации:**
   - Для больших данных используйте пагинацию с запросами к базе данных:
     ```python
     from django.core.paginator import Paginator
     from .models import Post

     def pagi(request):
         posts = Post.objects.all()
         paginator = Paginator(posts, 10)
         page = paginator.get_page(request.GET.get('page', 1))
         return render(request, 'pagi.html', {'page': page})
     ```

4. **Конвертеры:**
   - Создавайте конвертеры для сложных типов данных (например, дат, UUID) только при необходимости.
   - Проверяйте регулярные выражения в `regex` для предотвращения ошибок парсинга.

5. **Шаблоны:**
   - Используйте наследование шаблонов (`{% extends %}`) для повторяющихся элементов:
     ```html
     <!-- base.html -->
     <!DOCTYPE html>
     <html lang="en">
     <head>
         <meta charset="UTF-8">
         <title>{% block title %}My Site{% endblock %}</title>
     </head>
     <body>
         {% block content %}{% endblock %}
     </body>
     </html>

     <!-- demo.html -->
     {% extends 'base.html' %}
     {% block title %}Demo Page{% endblock %}
     {% block content %}
         <h1>{{ name }}, {{ age }}</h1>
     {% endblock %}
     ```