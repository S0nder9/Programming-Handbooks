# Регулярные выражения

Регулярные выражения (регулярки, regex) — это мощный инструмент для поиска, обработки и замены текста в строках на основе заданных шаблонов. Они представляют собой последовательность символов, описывающую определённый паттерн, который используется для сопоставления с текстом. Регулярные выражения широко применяются в программировании, обработке текстов, валидации данных и парсинге.

## Основные элементы регулярных выражений

1. **Символы и их значение**:
   - `.` — соответствует любому одиночному символу, кроме символа новой строки (`\n`). Например, шаблон `a.b` найдёт `acb`, `a1b`, `a#b`, но не `ab` или `a\nb`.
   - `^` — обозначает начало строки. Например, `^abc` найдёт строки, начинающиеся с `abc`, но не `xabc`.
   - `$` — обозначает конец строки. Например, `abc$` найдёт строки, заканчивающиеся на `abc`, но не `abcx`.
   - `*` — указывает на 0 или более вхождений предыдущего символа или группы. Например, `a*` соответствует `""` (пустая строка), `a`, `aa`, `aaa` и т.д.
   - `+` — указывает на 1 или более вхождений предыдущего символа или группы. Например, `a+` соответствует `a`, `aa`, `aaa`, но не `""`.
   - `?` — указывает на 0 или 1 вхождение предыдущего символа или группы. Например, `colou?r` соответствует `color` и `colour`.
   - `{n,m}` — задаёт точное количество вхождений от `n` до `m`. Например, `a{2,4}` соответствует `aa`, `aaa`, `aaaa`, но не `a` или `aaaaa`.
   - `{n}` — ровно `n` вхождений. Например, `a{3}` соответствует `aaa`.
   - `{n,}` — `n` или более вхождений. Например, `a{2,}` соответствует `aa`, `aaa` и т.д.
   - `\` — экранирующий символ, позволяет использовать специальные символы как обычные. Например, `\.` соответствует точке (`.`), а не любому символу.
   - `|` — логическое "или". Например, `cat|dog` соответствует `cat` или `dog`.

2. **Группировка и множества**:
   - `(...)` — группирует выражения, позволяя применять к ним квантификаторы (`*`, `+`, `?`, `{n,m}`) или использовать как подвыражение для последующей обработки. Например, `(ab)+` соответствует `ab`, `abab`, `ababab` и т.д.
   - `[...]` — задаёт множество символов. Например:
     - `[a-z]` — любая строчная буква от `a` до `z`.
     - `[A-Z]` — любая заглавная буква от `A` до `Z`.
     - `[0-9]` — любая цифра.
     - `[a-zA-Z]` — любая буква (строчная или заглавная).
     - `[^...]` — отрицание множества, соответствует любому символу, не входящему в указанное множество. Например, `[^0-9]` — любой символ, кроме цифры.

3. **Специальные символы**:
   - `\w` — буквенно-цифровой символ или подчёркивание (`[a-zA-Z0-9_]`).
   - `\W` — любой символ, кроме буквенно-цифрового или подчёркивания.
   - `\d` — любая цифра (`[0-9]`).
   - `\D` — любой символ, кроме цифры.
   - `\s` — пробельный символ (пробел, табуляция, перенос строки и т.д.).
   - `\S` — любой непробельный символ.
   - `\b` — граница слова. Например, `\bcat\b` найдёт `cat` как отдельное слово, но не `catfish` или `scat`.
   - `\B` — не граница слова. Например, `\Bcat\B` найдёт `cat` внутри слова, например, в `scat` или `catfish`, но не само слово `cat`.

## Примеры использования

1. **Поиск email-адреса**:
   Шаблон: `[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}`
   - `[a-zA-Z0-9._%+-]+` — один или более символов (буквы, цифры, точки, подчёркивания, знаки `%`, `+`, `-`) до знака `@`.
   - `@` — символ `@`.
   - `[a-zA-Z0-9.-]+` — доменное имя (буквы, цифры, точки, дефисы).
   - `\.` — точка перед доменной зоной.
   - `[a-zA-Z]{2,}` — доменная зона (например, `com`, `org`, `ru`).
   - Пример: `user123@example.com` — подходит, а `user@com` — нет.

2. **Поиск номера телефона**:
   Шаблон: `\+?\d{1,3}[-.\s]?\d{3}[-.\s]?\d{3}[-.\s]?\d{2}[-.\s]?\d{2}`
   - `\+?` — необязательный символ `+`.
   - `\d{1,3}` — код страны (1–3 цифры).
   - `[-.\s]?` — необязательный разделитель (дефис, точка или пробел).
   - `\d{3}` — три цифры (например, код региона).
   - `\d{2}` — две цифры (последние группы номера).
   - Пример: `+7-926-123-45-67`, `+79261234567`, `926.123.45.67` — подходят.

3. **Поиск слов определённой длины**:
   Шаблон: `\b\w{4}\b`
   - `\b` — граница слова.
   - `\w{4}` — ровно 4 буквенно-цифровых символа.
   - Пример: найдёт `word`, `test`, `1234`, но не `longword` или `cat`.

4. **Замена всех цифр на символ**:
   Шаблон: `\d`
   - Замена: `*`
   - Пример: строка `abc123def` превратится в `abc***def`.

## Работа с регулярными выражениями в Python

В Python для работы с регулярными выражениями используется модуль `re`. Рассмотрим несколько примеров использования регулярных выражений с этим модулем.

### Пример 1: Поиск всех вхождений шаблона

```python
import re

text = "Что такое Регулярные ВЫРАЖЕНИЯ и как их использовать? Говоря простым языком, регулярное выражение — это последовательность символов, используемая для поиска и замены текста в строке или файле. Как уже было упомянуто, их поддерживает множество языков общего назначения: Python, Perl, R. Так что изучение Регулярных выражений рано или поздно пригодится!"

pattern = r"регулярн\w+ выражен\w+"
result = re.findall(pattern, text, re.IGNORECASE)
print(result)  # ['Регулярные ВЫРАЖЕНИЯ', 'регулярное выражение', 'Регулярных выражений']
```

- `re.findall(pattern, text, re.IGNORECASE)` — ищет все вхождения шаблона в тексте, игнорируя регистр.
- Шаблон `регуularн\w+ выражен\w+` ищет словосочетания, начинающиеся с "регулярн", за которыми следует одна или более буквенно-цифровых символов, затем пробел и слово "выражен" с аналогичным окончанием.

### Пример 2: Поиск первого вхождения с помощью `re.match` и `re.search`

```python
result = re.match(pattern, text, re.IGNORECASE)
print(result)  # None, так как match проверяет только начало строки

result = re.search(pattern, text, re.IGNORECASE)
print(result)  # <re.Match object; span=(10, 31), match='Регулярные ВЫРАЖЕНИЯ'>
print(result.start(), result.end(), result.group())  # 10 31 Регулярные ВЫРАЖЕНИЯ
```

- `re.match(pattern, text, re.IGNORECASE)` — проверяет, начинается ли строка с указанного шаблона. В данном случае возвращает `None`, так как текст не начинается с "Регулярные ВЫРАЖЕНИЯ".
- `re.search(pattern, text, re.IGNORECASE)` — ищет первое вхождение шаблона в тексте и возвращает объект `Match`, содержащий информацию о позиции и найденной подстроке.

### Пример 3: Подсчёт количества слов

```python
result = re.findall(r"\w+", text, re.IGNORECASE)
print(result)  # Список всех слов
print(len(result))  # Количество слов
```

- Шаблон `\w+` находит все последовательности буквенно-цифровых символов (слова).
- `len(result)` возвращает общее количество слов в тексте.

### Пример 4: Разделение текста на предложения

```python
result = re.split(r"[.!?]\s*", text, re.IGNORECASE)
print(result)  # Список предложений
print(len(result))  # Количество предложений
```

- Шаблон `[.!?]\s*` разбивает текст на части по знакам препинания (`.`, `!`, `?`), за которыми следует ноль или более пробельных символов.
- `re.split` возвращает список предложений.

### Пример 5: Форматирование номеров телефонов

```python
text2 = '''
";http://customs.ru/index.php?
option=com_content&view=article&id=8018&Itemid=1878; "197720, Санкт-Петербург, г. Зеленогорск, Приморское шоссе, д. 511....
";7,80E+18;52168252;1,03E+12;7827000634; beloe-solnce@bests.ru; (812)433-31-16;" (812) 433-30-52; (812) 640-35-34
**"; "Секретарь начальника: 8
(812) 433-30-45; Бухгалтерия: +7 (812) 4-49-88; Заместитель начальника пансионата по административно-хозяйственной деятельности: 8 (812) 432-97-31;
****** Заместитель начальника пансионата профилактическо-оздоровительного отделения: 8 (812) 42-97-32; «Заместитель начальника пансионата-начальник филиала: 8 (40153)2-10 81;
Администратор по размещению: 8 (812)  4322131 97-33
";http://www.beloe-solnce.bests.ru-
"Государственное казенное учреждение ""Санаторий ""Победа""
ФТС России"""; """Санаторий ""Победа"" ФТС России"""; "Еременко
Николай Николаевич; Начальник санатория"; "Войтко Владимир
'''

pattern = r"(\+7|8)?\s*\((\d+)\)\s*(\d+)[-\s]*\s*(\d+)[-\s]*(\d+)"
subtitle = r"8-\2-\3-\4-\5"
result = re.sub(pattern, subtitle, text2)
print(result)  # Текст с отформатированными номерами телефонов
```

- Шаблон `(\+7|8)?\s*\((\d+)\)\s*(\d+)[-\s]*\s*(\d+)[-\s]*(\d+)` находит номера телефонов в формате `+7(код)XXX-YY-ZZ` или `8(код)XXX-YY-ZZ`.
- Группы в скобках позволяют извлечь части номера (код, цифры) и использовать их в замене.
- `re.sub` заменяет найденные номера на формат `8-код-XXX-YY-ZZ`.

### Пример 6: Использование `re.compile` для оптимизации

```python
pattern_compiled = re.compile(r"(\+7|8)?\s*\((\d+)\)\s*(\d+)[-\s]*\s*(\d+)[-\s]*(\d+)")
result = pattern_compiled.sub(subtitle, text2)
print(result)  # Текст с отформатированными номерами телефонов
```

- `re.compile` создаёт объект шаблона, который можно использовать многократно, что ускоряет выполнение при многократном использовании одного и того же шаблона.

### Пример 7: Извлечение групп из найденного номера телефона

```python
result = re.search(pattern, text2)
print(result)  # <re.Match object>
print(result.group(0))  # Полный номер телефона
print(result.group(1))  # +7 или 8
print(result.group(2))  # Код региона
print(result.group(3))  # Первая группа цифр
print(result.group(4))  # Вторая группа цифр
print(result.group(5))  # Третья группа цифр
```

- `re.search` возвращает объект `Match`, из которого можно извлечь группы с помощью `group(n)`.

## Полезные советы
- **Тестирование регулярных выражений**: Используйте онлайн-инструменты, такие как regex101.com или regexpal.com, для тестирования и отладки шаблонов.
- **Экранирование**: В Python специальные символы экранируются дополнительно. Например, точка пишется как `\.`, а обратный слеш — как `\\`.
- **Жадность и лень**: Квантификаторы (`*`, `+`, `{n,m}`) по умолчанию "жадные" (захватывают максимум символов). Чтобы сделать их "ленивыми" (захватывать минимум), добавьте `?`. Например, `<.*?>` найдёт минимальный тег HTML, а `<.*>` — максимальный.
- **Флаги**: Регулярные выражения могут использовать флаги для изменения поведения, например:
  - `re.IGNORECASE` — игнорировать регистр.
  - `re.MULTILINE` — многострочный режим (чтобы `^` и `$` работали для каждой строки).
  - `re.DOTALL` — режим, где `.` соответствует и символу новой строки.

## Применение в языках программирования
Регулярные выражения поддерживаются в большинстве языков программирования:
- **Python**: модуль `re` (`re.search`, `re.match`, `re.sub`, `re.findall`, `re.split`).
- **JavaScript**: объект `RegExp` или методы строк, такие как `match`, `replace`.
- **Perl**: встроенная поддержка регулярных выражений.
- **Java**: класс `Pattern` и `Matcher`.

## Ограничения
- Регулярные выражения могут быть сложными для чтения и отладки, особенно при большом количестве условий.
- Для сложных задач (например, парсинг HTML или JSON) лучше использовать специализированные библиотеки, такие как BeautifulSoup или парсеры JSON.

Регулярные выражения — это мощный, но требующий практики инструмент. Освоив их, вы сможете эффективно решать задачи обработки текста, валидации и поиска данных.