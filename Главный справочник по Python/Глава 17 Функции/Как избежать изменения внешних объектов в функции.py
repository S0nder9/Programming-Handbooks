# Глава 17: Функции - Как избежать изменения внешних объектов в функции

# В Python функции могут изменять объекты, которые передаются в них в качестве аргументов.
# Это может привести к неожиданным побочным эффектам, если вы не хотите, чтобы переданные объекты изменялись.
# Для предотвращения этого существуют несколько методов, которые позволяют избежать изменения внешних объектов внутри функции.

# Почему важно избегать изменения внешних объектов?
# Изменение внешних объектов внутри функции может привести к трудноотслеживаемым ошибкам и сделать код менее предсказуемым.
# Это особенно важно при работе с изменяемыми объектами, такими как списки и словари, которые могут быть изменены по ссылке.

# Способы избежать изменения внешних объектов в функции

# 1. Передача копий объектов
# Один из способов избежать изменения внешних объектов - это передавать копии объектов в функцию.
# Это можно сделать с помощью методов копирования, таких как copy() для списков или deepcopy() для вложенных объектов.

# Пример 1: Использование copy() для поверхностного копирования списка
import copy

def modify_list(input_list):
    input_list_copy = input_list.copy()
    input_list_copy.append(4)
    return input_list_copy

original_list = [1, 2, 3]
new_list = modify_list(original_list)

print("Оригинальный список:", original_list)
print("Измененный список:", new_list)

# Пример 2: Использование deepcopy() для глубокого копирования вложенных объектов
def modify_nested_list(input_list):
    input_list_copy = copy.deepcopy(input_list)
    input_list_copy[0].append(4)
    return input_list_copy

original_nested_list = [[1, 2, 3], [4, 5, 6]]
new_nested_list = modify_nested_list(original_nested_list)

print("Оригинальный вложенный список:", original_nested_list)
print("Измененный вложенный список:", new_nested_list)

# 2. Использование неизменяемых объектов
# Другой способ избежать изменения внешних объектов - это использование неизменяемых объектов, таких как кортежи (tuples).
# Неизменяемые объекты не могут быть изменены после их создания, что предотвращает случайные изменения.

# Пример 3: Использование кортежей вместо списков
def modify_tuple(input_tuple):
    new_tuple = input_tuple + (4,)
    return new_tuple

original_tuple = (1, 2, 3)
new_tuple = modify_tuple(original_tuple)

print("Оригинальный кортеж:", original_tuple)
print("Измененный кортеж:", new_tuple)

# Итог
# Избегать изменения внешних объектов в функции можно с помощью различных методов, таких как передача копий объектов и использование неизменяемых объектов.
# Эти подходы помогают предотвратить неожиданные побочные эффекты и сделать код более предсказуемым и безопасным.
