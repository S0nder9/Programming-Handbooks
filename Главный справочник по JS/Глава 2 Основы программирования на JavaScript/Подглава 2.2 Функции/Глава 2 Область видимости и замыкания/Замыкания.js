// Подглава 2.2: Замыкания (closures)

// Что такое замыкания и зачем они нужны
/*
Замыкание (closure) - это функция, которая запоминает свое лексическое окружение во время объявления и имеет доступ к переменным из этого окружения, даже после того, как это окружение перестало существовать. 
Замыкания полезны для создания чистых и изолированных областей видимости, сохранения приватных переменных и реализации функций обратного вызова (callback).
*/

// Примеры использования замыканий
// Пример 1: Создание приватных переменных
function createCounter() {
    let count = 0;

    return function() {
        count++;
        console.log(count);
    };
}

const counter = createCounter();
counter(); // Выведет: 1
counter(); // Выведет: 2
counter(); // Выведет: 3

/*
В этом примере функция createCounter создает и возвращает функцию, которая увеличивает счетчик при каждом вызове. 
Переменная count остается приватной за счет замыкания и не доступна извне.
*/

// Пример 2: Использование замыканий для реализации функции обратного вызова
function delay(callback, ms) {
    setTimeout(callback, ms);
}

function sayHello() {
    console.log("Привет!");
}

delay(sayHello, 2000); // Выведет: Привет! через 2 секунды

/*
В этом примере функция delay принимает функцию обратного вызова (callback) и время задержки (ms). 
При вызове delay с функцией sayHello в качестве аргумента, создается замыкание, которое запоминает функцию sayHello и время задержки. 
Таким образом, функция sayHello будет вызвана через указанное время.
*/

// Утечки памяти и замыкания
/*
Замыкания могут привести к утечкам памяти, если в замыкании используются большие объемы данных или циклические ссылки. 
Это происходит потому, что замыкание сохраняет ссылки на все переменные из его лексического окружения, 
что может привести к тому, что они не будут удалены сборщиком мусора даже после того, как замыкание перестанет быть доступным.
*/

// Пример утечки памяти
function createLeak() {
    const data = new Array(1000000).fill('memory leak');
    return function() {
        console.log(data.length);
    };
}

const leakyFunction = createLeak();
// После использования leakyFunction необходимо присвоить ей значение null или undefined, чтобы разорвать ссылку на замыкание и избежать утечки памяти.
leakyFunction();
