// Глава 4: Цикл событий - Архитектура Node.js

// В этой главе мы рассмотрим важные аспекты архитектуры Node.js, связанные с обработкой событий и асинхронностью. 
// Мы сосредоточимся на двух ключевых концепциях: `process.nextTick` и колбэках промисов. 

// Подглава 3.1: Событие process.nextTick

// `process.nextTick` — это функция в Node.js, которая позволяет вам отложить выполнение функции до следующего цикла событий.
// Важно понимать, как и когда использовать `process.nextTick` для управления асинхронным поведением.

console.log("Start");

// process.nextTick() принимает функцию обратного вызова, которая будет вызвана в следующем цикле событий,
// перед выполнением любых других асинхронных операций, таких как таймеры или события.
process.nextTick(() => {
  console.log("Next Tick Callback"); 
});

console.log("End");

// Вывод будет следующим:
// Start
// End
// Next Tick Callback

// Важно отметить, что `process.nextTick` ставит функцию в начало очереди микротасков, которая выполняется перед макротасками.

// Подглава 3.2: Колбэки промисов

// Промисы — это один из основных способов обработки асинхронного кода в JavaScript, и Node.js поддерживает их.
// Промисы позволяют работать с асинхронными операциями, управляя состоянием выполнения задач: ожидание, выполнение и ошибка.

// Основные состояния промисов:
// 1. Pending (Ожидание): Начальное состояние, пока промис не выполнен или не отклонен.
// 2. Fulfilled (Исполнен): Промис успешно завершен, и его значение доступно.
// 3. Rejected (Отклонен): Промис завершен с ошибкой, и причина ошибки доступна.

console.log("Promise Example");

const myPromise = new Promise((resolve, reject) => {
  // Эта функция будет вызвана сразу после создания промиса.
  setTimeout(() => {
    const success = true; // Измените это значение для проверки разных состояний промиса.
    if (success) {
      resolve("Data loaded successfully!");
    } else {
      reject("Error occurred while loading data.");
    }
  }, 1000);
});

// then() и catch() — методы для обработки результатов промиса.
// then() используется для обработки успешного выполнения промиса.
// catch() используется для обработки ошибок.

myPromise
  .then((data) => {
    console.log(data); // "Data loaded successfully!"
  })
  .catch((error) => {
    console.error(error); // Обработать ошибку, если промис завершился с ошибкой.
  });

// Промисы могут быть объединены в цепочку, позволяя последовательно выполнять асинхронные операции.

myPromise
  .then((data) => {
    console.log(data);
    return "Next data";
  })
  .then((data) => {
    console.log(data); // "Next data"
  })
  .catch((error) => {
    console.error(error);
  });

// Подглава 3.3: Сравнение process.nextTick и промисов

// `process.nextTick` и промисы оба являются способами управления асинхронным кодом, но они действуют в разных частях цикла событий.

// Сравнение `process.nextTick` и промисов:

// 1. `process.nextTick` ставит функции в начало очереди микротасков, которые выполняются до макротасков (например, таймеров).
// 2. Промисы создают цепочку асинхронных операций и могут использоваться для обработки результатов и ошибок.
// 3. `process.nextTick` используется для немедленного выполнения функции после текущего кода, но перед другими асинхронными задачами.
// 4. Промисы создают более структурированный способ работы с асинхронными операциями и поддерживают цепочки вызовов и обработку ошибок.

console.log("Comparing process.nextTick and Promises");

// Пример: `process.nextTick` запланирован перед макротасками, даже если они позже запланированы.
process.nextTick(() => {
  console.log("process.nextTick Callback");
});

setTimeout(() => {
  console.log("setTimeout Callback");
}, 0);

// Вывод будет:
// Comparing process.nextTick and Promises
// process.nextTick Callback
// setTimeout Callback

// Итог:
// `process.nextTick` и промисы являются важными инструментами в Node.js для управления асинхронностью. 
// `process.nextTick` полезен для управления немедленной асинхронной работой, тогда как промисы лучше подходят для работы с асинхронными задачами, требующими цепочки операций и обработки ошибок.

