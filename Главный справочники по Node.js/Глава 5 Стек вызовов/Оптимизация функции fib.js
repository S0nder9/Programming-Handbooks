// Глава 5: Стек вызовов

// Оптимизация функции fib

// Функция Fibonacci (fib) вычисляет числа в последовательности Фибоначчи, где каждое число является суммой двух предыдущих чисел.
// Однако, базовая реализация через рекурсию может быть неэффективной, так как приводит к множественным повторным вычислениям одних и тех же значений.

// Рассмотрим базовую рекурсивную реализацию функции Fibonacci:
function fib(n) {
  if (n <= 1) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}

// Хотя эта реализация проста и понятна, она имеет экспоненциальную временную сложность, что делает её непрактичной для больших значений n.

// Чтобы улучшить производительность, можно использовать оптимизацию с мемоизацией, чтобы избежать повторных вычислений.

function memoizedFib() {
  const cache = {}; // создаем объект для хранения уже вычисленных значений

  function fib(n) {
    if (n <= 1) {
      return n;
    }
    if (cache[n]) {
      return cache[n]; // возвращаем значение из кеша, если оно уже было вычислено
    }
    cache[n] = fib(n - 1) + fib(n - 2); // вычисляем и сохраняем значение в кеш
    return cache[n];
  }

  return fib;
}

const fibWithMemo = memoizedFib();

console.log(fibWithMemo(10)); // 55
console.log(fibWithMemo(20)); // 6765
console.log(fibWithMemo(50)); // 12586269025

// Этот подход значительно уменьшает количество рекурсивных вызовов, поскольку ранее вычисленные значения сохраняются в кеше и повторно используются при необходимости.

// Еще один способ оптимизации функции Fibonacci — использовать итеративный подход. Он имеет линейную временную сложность и не использует стек вызовов.

function iterativeFib(n) {
  if (n <= 1) {
    return n;
  }
  let a = 0, b = 1;
  for (let i = 2; i <= n; i++) {
    const temp = a + b;
    a = b;
    b = temp;
  }
  return b;
}

console.log(iterativeFib(10)); // 55
console.log(iterativeFib(20)); // 6765
console.log(iterativeFib(50)); // 12586269025

// Итеративный метод не только более эффективен, но и избегает проблем с переполнением стека вызовов, что может произойти в рекурсивной реализации при больших значениях n.

// Итог:
// Оптимизация функции Fibonacci может существенно повысить её производительность.
// Мемоизация и итеративный подход — два основных метода, которые помогают снизить количество повторных вычислений и улучшить временную сложность.
// Используйте эти техники для повышения эффективности ваших программ, особенно при работе с рекурсивными функциями.
