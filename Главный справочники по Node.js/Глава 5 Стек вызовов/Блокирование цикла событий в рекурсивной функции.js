// Глава 5: Стек вызовов

// Стек вызовов (call stack) - это структура данных, используемая для отслеживания выполнения функций в JavaScript.
// Он работает по принципу LIFO (Last In, First Out), где последняя вызванная функция обрабатывается первой.

// Блокирование цикла событий в рекурсивной функции

// Когда функция вызывает саму себя (рекурсия), она добавляется в стек вызовов, что может привести к переполнению стека, 
// если рекурсия не контролируется должным образом.

// Пример рекурсивной функции, которая может блокировать цикл событий:

function recursiveFunction(n) {
  if (n === 0) return;
  console.log(n);
  recursiveFunction(n - 1);
}

// Вызов этой функции с большим значением n приведет к тому, что стек вызовов переполнится:
recursiveFunction(100000);

// Важно понимать, что каждая функция в JavaScript добавляется в стек вызовов. 
// Когда стек переполняется, происходит ошибка "Maximum call stack size exceeded".

// Контролируемая рекурсия:

// Чтобы избежать блокировки цикла событий и переполнения стека вызовов, можно использовать техники оптимизации,
// такие как хвостовая рекурсия или итеративные решения.

function tailRecursiveFunction(n, acc = 0) {
  if (n === 0) return acc;
  return tailRecursiveFunction(n - 1, acc + n);
}

// Оптимизация хвостовой рекурсии заключается в том, что последняя операция в функции - это рекурсивный вызов,
// что позволяет двигателю JavaScript оптимизировать использование стека вызовов.

console.log(tailRecursiveFunction(10000));

// Итеративное решение:

function iterativeFunction(n) {
  let result = 0;
  for (let i = 1; i <= n; i++) {
    result += i;
  }
  return result;
}

console.log(iterativeFunction(10000));

// Преимущества использования итеративного подхода включают:
// 1. Отсутствие риска переполнения стека вызовов.
// 2. Возможность более эффективного использования памяти и процессорного времени.

// Блокирование цикла событий также может произойти при длительном выполнении функций, 
// что приводит к тому, что другие события, такие как пользовательский ввод или таймеры, не могут быть обработаны.

function blockEventLoop() {
  let start = Date.now();
  let end = start + 5000; // блокируем цикл событий на 5 секунд
  while (Date.now() < end) {
    // выполняем пустую операцию
  }
  console.log('Цикл событий был заблокирован на 5 секунд.');
}

blockEventLoop();
console.log('Этот код выполнится только после завершения blockEventLoop.');

// Для избежания блокировки цикла событий, длительные операции следует разбивать на более мелкие части
// и выполнять их асинхронно с использованием setTimeout, requestAnimationFrame или других асинхронных методов.

function nonBlockingFunction() {
  let count = 0;
  function incrementCounter() {
    if (count < 1e6) {
      count++;
      if (count % 100000 === 0) {
        console.log(`Текущий счет: ${count}`);
      }
      setTimeout(incrementCounter, 0); // асинхронное выполнение
    } else {
      console.log('Цикл завершен.');
    }
  }
  incrementCounter();
}

nonBlockingFunction();
console.log('Этот код выполнится сразу же, не дожидаясь завершения nonBlockingFunction.');

// Итог:
// Стек вызовов - это важный механизм, обеспечивающий выполнение функций в JavaScript. 
// Неконтролируемая рекурсия может привести к переполнению стека вызовов и блокировке цикла событий.
// Использование оптимизаций, таких как хвостовая рекурсия или итеративные подходы, позволяет избежать этих проблем 
// и улучшить производительность вашего кода.
